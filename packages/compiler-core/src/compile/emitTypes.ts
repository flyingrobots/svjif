import type { CanonicalSceneAst, NodeKind } from '../types/ast';
import type { Artifact } from '../types/artifacts';
import { buildIdentifierMap } from '../util/identifiers';

// Per-kind prop type definitions (only the commonly typed fields)
const KIND_PROP_TYPES: Record<NodeKind, Array<[string, string, boolean]>> = {
  // [propName, tsType, required]
  Rect: [
    ['x', 'number', false],
    ['y', 'number', false],
    ['width', 'number', true],
    ['height', 'number', true],
    ['fill', 'string', false],
    ['stroke', 'string', false],
    ['strokeWidth', 'number', false],
    ['cornerRadius', 'number', false],
    ['rotation', 'number', false],
    ['opacity', 'number', false],
  ],
  Text: [
    ['x', 'number', false],
    ['y', 'number', false],
    ['content', 'string', true],
    ['color', 'string', false],
    ['fontFamily', 'string', false],
    ['fontSize', 'number', false],
    ['fontWeight', 'number | string', false],
    ['lineHeight', 'number', false],
    ['letterSpacing', 'number', false],
    ['align', "'left' | 'center' | 'right'", false],
    ['valign', "'top' | 'middle' | 'bottom'", false],
    ['rotation', 'number', false],
    ['opacity', 'number', false],
  ],
  Image: [
    ['x', 'number', false],
    ['y', 'number', false],
    ['width', 'number', false],
    ['height', 'number', false],
    ['src', 'string', true],
    ['fit', "'cover' | 'contain' | 'fill'", false],
    ['alt', 'string', false],
    ['rotation', 'number', false],
    ['opacity', 'number', false],
  ],
  Group: [
    ['x', 'number', false],
    ['y', 'number', false],
    ['width', 'number', false],
    ['height', 'number', false],
    ['rotation', 'number', false],
    ['opacity', 'number', false],
  ],
  Line: [
    ['x', 'number', false],
    ['y', 'number', false],
    ['x2', 'number', true],
    ['y2', 'number', true],
    ['stroke', 'string', false],
    ['strokeWidth', 'number', false],
    ['rotation', 'number', false],
    ['opacity', 'number', false],
  ],
  Ellipse: [
    ['x', 'number', false],
    ['y', 'number', false],
    ['rx', 'number', true],
    ['ry', 'number', true],
    ['fill', 'string', false],
    ['stroke', 'string', false],
    ['strokeWidth', 'number', false],
    ['rotation', 'number', false],
    ['opacity', 'number', false],
  ],
  Path: [
    ['x', 'number', false],
    ['y', 'number', false],
    ['d', 'string', true],
    ['fill', 'string', false],
    ['stroke', 'string', false],
    ['strokeWidth', 'number', false],
    ['rotation', 'number', false],
    ['opacity', 'number', false],
  ],
};

export class TypeEmitter {
  private readonly ast: CanonicalSceneAst;

  constructor(ast: CanonicalSceneAst) {
    this.ast = ast;
  }

  emit(): string {
    const tokens: string[] = [];

    tokens.push('// Auto-generated by @svjif/compiler-core â€” do not edit\n');
    tokens.push('\n');

    // NodeId union
    const nodeIds = this.ast.nodes.map((n) => n.id);
    this.emitNodeIdType(tokens, nodeIds);

    tokens.push('\n');

    // SceneRoot interface
    this.emitSceneRootInterface(tokens);

    tokens.push('\n');

    // Per-kind interfaces (only kinds present in scene)
    const kindsPresent = [...new Set(this.ast.nodes.map((n) => n.kind as NodeKind))].sort();
    for (const kind of kindsPresent) {
      this.emitKindInterface(tokens, kind);
      tokens.push('\n');
    }

    // SceneNode union
    this.emitSceneNodeUnion(tokens, kindsPresent);

    tokens.push('\n');

    return tokens.join('');
  }

  private emitNodeIdType(tokens: string[], nodeIds: string[]): void {
    tokens.push('export type NodeId = ');
    if (nodeIds.length === 0) {
      tokens.push('never');
    } else {
      tokens.push(nodeIds.map((id) => JSON.stringify(id)).join(' | '));
    }
    tokens.push(';\n');
  }

  private emitSceneRootInterface(tokens: string[]): void {
    tokens.push('export interface SceneRoot {\n');
    tokens.push('  id: string;\n');
    tokens.push('  width: number;\n');
    tokens.push('  height: number;\n');
    tokens.push('  background?: string;\n');
    tokens.push('}\n');
  }

  private emitKindInterface(tokens: string[], kind: NodeKind): void {
    const ifaceName = `${kind}Node`;
    const props = KIND_PROP_TYPES[kind] ?? [];

    tokens.push(`export interface ${ifaceName} {\n`);
    tokens.push('  id: string;\n');
    tokens.push(`  kind: "${kind}";\n`);
    tokens.push('  props: {\n');
    for (const [propName, propType, required] of props) {
      const opt = required ? '' : '?';
      tokens.push(`    ${propName}${opt}: ${propType};\n`);
    }
    tokens.push('  };\n');
    tokens.push('}\n');
  }

  private emitSceneNodeUnion(tokens: string[], kindsPresent: NodeKind[]): void {
    tokens.push('export type SceneNode = ');
    if (kindsPresent.length === 0) {
      tokens.push('never');
    } else {
      tokens.push(kindsPresent.map((k) => `${k}Node`).join(' | '));
    }
    tokens.push(';\n');
  }
}

export function emitTypesArtifact(ast: CanonicalSceneAst): Artifact {
  const emitter = new TypeEmitter(ast);
  const content = emitter.emit();
  return {
    path: 'types.ts',
    content,
    mediaType: 'text/plain',
    encoding: 'utf8',
  };
}

/**
 * Re-export for consumers who only need identifier utilities.
 */
export { buildIdentifierMap };
